:toc:
:icons: font
:source-highlighter: prettify
:sectnums:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

= Customization & Extension Guide

In this tutorial, weâ€™ll extend a custom entity from Broadleaf `CatalogServices` library.

[TIP]
====
Once you're done, you can check your customizations against the sample code at:
`MicroservicesTutorial/ms-tutorial-extension-complete`
====

== Product Repository Domain

In this section, we're going to add a new attribute to the `Product` *repository* domain.

=== Extension Example
We're going to create a simple `String` property on `JpaProduct` to demonstrate extending a base
framework *repository* domain.

[source,java]
----
package com.broadleafsamples.tutorials.services.catalog.provider.jpa.domain;

import com.broadleafcommerce.catalog.provider.jpa.domain.product.JpaProduct;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Table;

import lombok.Data;
import lombok.EqualsAndHashCode;

@Entity
@Table(name = "TUTORIAL_PRODUCT")
@Data
@EqualsAndHashCode(callSuper = true)
public class TutorialJpaProduct extends JpaProduct {

    private static final long serialVersionUID = 1L;

    @Column(name = "MY_PROPERTY")
    private String myProperty;
}
----

Next, you'll need to inform the system of your new entity. Add a `@JpaEntityScan` for your new file.

[source,java]
----
package com.broadleafsamples.tutorials.services.catalog.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.stereotype.Component;

import com.broadleafcommerce.catalog.metadata.product.CommonPriceDataComponents;
import com.broadleafcommerce.catalog.metadata.product.IncludedProductFields;
import com.broadleafcommerce.catalog.metadata.product.NonSkuPriceDataComponents;
import com.broadleafcommerce.catalog.metadata.product.ProductFields;
import com.broadleafcommerce.catalog.metadata.product.ProductForms;
import com.broadleafcommerce.catalog.metadata.product.ProductOptionFields;
import com.broadleafcommerce.catalog.metadata.product.ProductOptionForms;
import com.broadleafcommerce.catalog.metadata.product.PromotionalProductFields;
import com.broadleafcommerce.catalog.metadata.product.VariantFields;
import com.broadleafcommerce.catalog.metadata.product.pricing.PriceDataFields;
import com.broadleafcommerce.metadata.domain.FieldComponent;
import com.broadleafcommerce.metadata.domain.builder.EntityFormBuilder;

@Configuration
@JpaEntityScan(basePackages = "com.broadleafsamples.tutorials.services.catalog.provider.jpa.domain",
        routePackage = "com.broadleafcommerce.catalog")
@AutoConfigureAfter(CatalogJpaAutoConfiguration.class)
public class TutorialCatalogConfig {

    // other beans and configurations here

}
----

== Admin Metadata Customizations

If you run the app at this point and check the Products page in the Admin, you will
notice a couple things. Firstly, there are no longer any products in the Listgrid. That is because this Listgrid is now
displaying TutorialJpaProducts, not JpaProducts, which still exist but don't have an entry in the new, extended entity table.
New products will display normally.
Secondly, new products do not have myProperty displayed. This is because the Admin
needs to be informed of the new field in order for it to display.

==== Extension Example
To have myProperty displayed, we'll need to create a new Metadata Config class that extends some built in
product components.

[source,java]
----
import org.springframework.context.annotation.Configuration;
import org.springframework.stereotype.Component;

import com.broadleafcommerce.catalog.metadata.product.CommonPriceDataComponents;
import com.broadleafcommerce.catalog.metadata.product.IncludedProductFields;
import com.broadleafcommerce.catalog.metadata.product.NonSkuPriceDataComponents;
import com.broadleafcommerce.catalog.metadata.product.ProductFields;
import com.broadleafcommerce.catalog.metadata.product.ProductForms;
import com.broadleafcommerce.catalog.metadata.product.ProductOptionFields;
import com.broadleafcommerce.catalog.metadata.product.ProductOptionForms;
import com.broadleafcommerce.catalog.metadata.product.PromotionalProductFields;
import com.broadleafcommerce.catalog.metadata.product.VariantFields;
import com.broadleafcommerce.catalog.metadata.product.pricing.PriceDataFields;
import com.broadleafcommerce.metadata.domain.FieldComponent;
import com.broadleafcommerce.metadata.domain.builder.EntityFormBuilder;

@Configuration
public class TutorialMetadataConfig {

    @Component
    class TutorialProductFields extends ProductFields {

        public static final String MY_PROPERTY = "myProperty";

        public TutorialProductFields() {
            super();
            add(FieldComponent.builder(MY_PROPERTY)
                    .label("My Property")
                    .required(false)
                    .translatable(false));
        }

    }

    @Component
    class TutorialProductForms extends ProductForms {

        public TutorialProductForms(ProductFields productFields,
                ProductOptionFields productOptionFields, VariantFields variantFields,
                PromotionalProductFields promotionalProductFields,
                IncludedProductFields includedProductFields, PriceDataFields priceDataFields,
                CommonPriceDataComponents commonPriceDataComponents, ProductOptionForms optionForms,
                NonSkuPriceDataComponents nonSkuPriceDataComponents) {
            super(productFields, productOptionFields, variantFields, promotionalProductFields,
                    includedProductFields, priceDataFields, commonPriceDataComponents, optionForms,
                    nonSkuPriceDataComponents);
        }

        @Override
        protected EntityFormBuilder generalForm() {
            return super.generalForm()
                    .addField(getProductFields().get(TutorialProductFields.MY_PROPERTY)
                            .order(20000).build());
        }
    }
}

== Customizing a Service

In this section, let's walk through customizing the service tier.

=== Overview
The service tier is responsible for executing business logic against projections and represents
the main source of business requirement fulfillment in the microservice. Like other Broadleaf
components, service components load in a deferred loader and will be ignored if another bean of
the same type is already registered. This allows for an extended service to be loaded instead of
the out-of-the-box Broadleaf service. Existing methods may be overridden, or new ones introduced.

=== Extension Example
Let's add some additional logging to denote how you may want to hook into the execution of certain
business flows. In this case, let's add some arbitrary logging in the creation flow of a `Product`.

[source,java]
----
package com.broadleafsamples.tutorials.services.catalog.service;

import com.broadleafcommerce.catalog.repository.product.ProductRepository;
import com.broadleafcommerce.catalog.service.product.DefaultProductService;
import com.broadleafcommerce.catalog.service.product.VariantService;
import com.broadleafcommerce.data.tracking.core.context.ContextInfo;
import com.broadleafcommerce.data.tracking.core.service.RsqlCrudEntityHelper;

import lombok.extern.apachecommons.CommonsLog;

@CommonsLog
public class TutorialProductService extends DefaultProductService {

    public TutorialProductService(ProductRepository repository, RsqlCrudEntityHelper helper,
            VariantService variantService) {
        super(repository, helper, variantService);
    }

    @Override
    public Object create(Object businessInstance, ContextInfo context) {
        log.info("EXTENSION TUTORIAL - DEMONSTRATE EXECUTION OF CUSTOM BUSINESS LOGIC");
        return super.create(businessInstance, context);
    }
}

[IMPORTANT]
===
You must still register your component with Spring either by component scanning or explicitly
defining the `@Bean` in your own configuration class. If you have followed the tutorial up to this point,
you can add the following Bean definition to your `TutorialCatalogConfig` file.

[source,java]
----
@Bean
public ProductService<Product> customProductService(
        ProductRepository<Trackable> productRepository,
        RsqlCrudEntityHelper helper,
        VariantService<Variant> variantService) {
    return new TutorialProductService(productRepository, helper, variantService);
}
----
